#!/usr/bin/env bash

STAGE_ONE="jraph_build"
STAGE_TWO="jraph"
IMAGE_NAME="$STAGE_TWO:latest"
TEST_DATABASE="testdb"
JRAPH_DATABASE="jraph"
LOCAL_URL="localhost:5000"
DROPLET_URL="jraph.nathanielhtaylor.com"
DROPLET_ID="444418486"

_check_pass () {
	if [[ ! -v JRAPH_SA_PASSWORD ]]; then
		echo "\$JRAPH_SA_PASSWORD required!"
		exit 1
	fi
}

build.stage_one () {
	echo "creating $STAGE_ONE"
	podman create \
		--env-file="secrets.env" \
		--memory="2g" \
		--name="$STAGE_ONE" \
		--workdir="/root" \
		--interactive \
		--tty \
		--publish-all \
		--replace \
		--volume="./:/root/jraph:Z" \
		"fedora:latest" \
		"jraph/install-sqlserver.sh"

	echo "starting $STAGE_ONE"
	podman start --attach --interactive $STAGE_ONE
	# TODO make it so sqlserver doesn't try to start at the end of 
	# the msql configuration process
	
	echo "committing $STAGE_ONE to $IMAGE_NAME"
	podman commit \
		--change CMD=/opt/mssql/bin/sqlservr \
		$STAGE_ONE \
		$IMAGE_NAME
}

build.stage_two () {
	echo "creating local jraph container $STAGE_TWO"
	podman create \
		--env-file="secrets.env" \
		--interactive \
		--tty \
		--publish 127.0.0.1:5000:5000 \
		--volume="./:/root/jraph:Z" \
		--name="$STAGE_TWO" \
		--replace \
		"$IMAGE_NAME"
}

build () {
	# TODO REDO using CONTAINERFILE
	# TODO mssql-server and jraph service on startup 
	# TODO configgify msql setup options
	build.stage_one
	build.stage_two
}

# start a shell inside the local running jraph service container
# $ ./ndev loc
loc () {
	podman exec --interactive --tty \
		$STAGE_TWO /bin/bash
}

loc.start.server () {
	podman start "$@" $STAGE_TWO
}

loc.start () {
	podman exec --interactive --tty $STAGE_TWO \
		jraph/devops/run-dev.sh
}

loc.status () {
	echo "TODO implement loc.status!"
}

loc.test.sqlserver () {
	_check_pass
	podman exec --interactive --tty \
		$STAGE_TWO \
		/opt/mssql-tools18/bin/sqlcmd \
			-C -U sa -P $JRAPH_SA_PASSWORD \
			-i jraph/lib/testdb-init.sql 
}

# make a request to the running jraph service
# $ ./ndev client_request 3
loc.client_request () {
		curl $LOCAL_URL/query?node_id=$1
}

# run an input sql file in the running sqlserver instance
# $ ./ndev sql jraph/lib/example.sql
loc.sql () {
	_check_pass
	podman exec --interactive --tty \
		$STAGE_TWO \
		/opt/mssql-tools18/bin/sqlcmd \
			-C -U sa -P $JRAPH_SA_PASSWORD -W \
			-i $1
}

# start a shell in the running jraph droplet
# $ ./ndev doc
doc () {
	ssh root@$DROPLET_URL
}

# turn power for droplet on or off
# $ ./ndev doc.power on|off
doc.power () {
	doctl compute da power-$1 $DROPLET_ID
}

# push all run files to digital ocean 
# $ ./ndev doc.sync
doc.sync () {
	rsync -av --delete \
		--exclude=__pycache__/ \
		--exclude=.git/ \
		--exclude=.gitignore \
		--exclude=*.EXAMPLE \
		--exclude=ndev \
		--exclude=README.md \
		./ root@$DROPLET_URL:/root/jraph
}

doc.start () {
	ssh root@$DROPLET_URL ./jraph/devops/run-prod.sh
}

doc.kill () {
	ssh root@$DROPLET_URL "pkill flask"
}

doc.status () {
	echo "TODO implement doc.status!"
}

# TODO create help function which lists functions and their docstrings
# Has ability to limit to one docstring e.g.
# $ ndev --help **prints all docstrings**
# $ ndev build --help **prints build docstring**
if [[ $# -eq 0 ]]; then
	echo "available ndev functions..."
	grep -oP '^[^_][\w\.]+ \(\)' $0 | sort 
	exit 0
fi

"$@"
